import {MQTTBaseClient} from './base.jsy'

#IF PLAT_NODEJS
  import {connect as tcp_connect} from 'net'


export class MQTTCoreClient extends MQTTBaseClient ::
  static _with_session(mqtt_session) ::
    this.prototype._mqtt_session = mqtt_session

  constructor(opt={}) ::
    super(opt)
    this.with(opt)

  with(fns_ns) ::
    for let [k,v] of Object.entries(fns_ns) ::
      if k.startsWith('on_') :: this[k] = v
    return this

  // on_live(client) ::
  with_live(on_live) :: return this.with({on_live})

  // on_reconnect(client) ::
  with_reconnect(on_reconnect) :: return this.with({on_reconnect})

  _use_conn(fn_reconnect) ::
    return (this.reconnect = fn_reconnect)?.()
  with_autoreconnect(opt=2000) ::
    if opt.toFixed :: opt = @{} delay: opt
    return this.with @:
      on_reconnect() ::
        this.delay(opt.delay || 2000)
          .then(this.reconnect)
          .then(opt.reconnect, opt.error)

  async on_disconnect(client, intentional) ::
    if ! intentional && client.on_reconnect ::
      await client.on_reconnect()
      if ! client.on_live ::
        await client.connect()

  delay(ms) ::
    return new Promise @ done => setTimeout(done, ms)

  on_error(err, err_path) ::
    console.warn @ '[[u8-mqtt error: %s]]', err_path, err

  with_async_iter(async_iter, write_u8_pkt) ::
    let on_mqtt_chunk = this._conn_.set @
      this._mqtt_session(),
      write_u8_pkt

    this._msg_loop = @!>
      try ::
        async_iter = await async_iter
        for await (let chunk of async_iter)
          on_mqtt_chunk(chunk)
        this._conn_.reset()
      catch err ::
        this._conn_.reset(err)

    return this


  #IF PLAT_DENO
    with_tcp(port, hostname) ::
      if !Number.isFinite(port) ::
        ({port, hostname} = new URL(port))

      return this._use_conn @::
        let conn = Deno.connect @:
          port, hostname, transport: 'tcp'

        this.with_async_iter @
          conn.then @ Deno.iter,
          async u8_pkt => (await conn).write(u8_pkt)

        return this


  #IF PLAT_NODEJS
    with_tcp(port, hostname) ::
      if !Number.isFinite(port) ::
        ({port, hostname} = new URL(port))

      return this._use_conn @=>
        this.with_stream @
          tcp_connect(port, hostname)


  #IF HAS_STREAM
    with_stream(read_stream, write_stream) ::
      if undefined === write_stream ::
        write_stream = read_stream

      return this.with_async_iter @ read_stream,
        u8_pkt => write_stream.write(u8_pkt)




  with_websock(websock) ::
    if null == websock ::
      websock = 'ws://127.0.0.1:9001'

    if websock.send ::
      return this._with_websock(websock)

    websock = new URL(websock)
    return this._use_conn @=>
      this._with_websock @
        new WebSocket(websock, ['mqtt'])


  _with_websock(websock) ::
    websock.binaryType = 'arraybuffer'

    let ready, {readyState} = websock
    if 1 !== readyState ::
      if 0 !== readyState ::
        throw new Error @ 'Invalid WebSocket readyState'

      ready = new Promise @ fn => websock.onopen = fn


    let {_conn_} = this
    let on_mqtt_chunk = _conn_.set @
      this._mqtt_session(),
      async u8_pkt => @
        await ready
        websock.send(u8_pkt)

    websock.onmessage = evt => @ on_mqtt_chunk @ new Uint8Array(evt.data)
    websock.onclose = evt => ::
      if ! evt.wasClean ::
        var err = new Error('websocket connection close')
        err.code = evt.code
        err.reason = evt.reason

      _conn_.reset(err)

    return this

