import MQTTBaseClient from './base.jsy'

#IF PLAT_NODEJS
  import {connect as tcp_connect} from 'net'


export default MQTTCoreClient
export class MQTTCoreClient extends MQTTBaseClient ::
  static _with_session(mqtt_session) ::
    this.prototype._mqtt_session = mqtt_session


  #IF PLAT_NODEJS
    with_tcp(...args) ::
      const sock = args.length
        ? tcp_connect(...args)
        : tcp_connect(1883)
      return this.with_stream(sock)


  #IF HAS_STREAM
    async with_stream(duplex_stream) ::
      const on_mqtt_chunk = this._conn_.set @
        this._mqtt_session
        u8_pkt => duplex_stream.write(u8_pkt)

      duplex_stream.once @ 'end', this._conn_.reset

      this._msg_loop = @!>
        for await const chunk of duplex_stream ::
          on_mqtt_chunk @ chunk

      return this


  async with_websock(websock) ::
    if null == websock ::
      websock = 'ws://127.0.0.1:9001'

    if websock.origin || 'string' === typeof websock ::
      websock = new WebSocket(new URL(websock), ['mqtt'])

    const {readyState} = websock
    websock.binaryType = 'arraybuffer'
    if 1 !== readyState ::
      if 0 !== readyState ::
        throw new Error @ 'Invalid WebSocket readyState'

      await new Promise @ y =>
        websock.addEventListener @ 'open', y, {once: true}


    const {_conn_} = this
    const on_mqtt_chunk = _conn_.set @
      this._mqtt_session
      u8_pkt => websock.send @ u8_pkt

    websock.addEventListener @ 'close',
      @::
        delete websock.onmessage
        _conn_.reset()

      {once: true}

    websock.onmessage = evt =>
      on_mqtt_chunk @
        new Uint8Array(evt.data)

    return this

