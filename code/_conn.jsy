import { ao_defer_v } from 'roap'
export { ao_defer_v }

export function _mqtt_conn(client, [on_mqtt, pkt_future]) ::
  let _q_init = ao_defer_v(), _q_ready = ao_defer_v()
  let _send_ready = async (...args) => (await _q_ready[0])(...args)
  let _send_mqtt_pkt
  client._send = _send_ready

  return @{}
    async when_ready() ::
      if ! _send_mqtt_pkt ::
        await _q_ready[0]

    ping: _ping_interval @=> _send_mqtt_pkt?.('pingreq')

    reset(err) ::
      if ! _send_mqtt_pkt :: return

      if err ::
        _q_init[2](err)
        _async_evt('on_reset_error', err)

      _send_mqtt_pkt = null
      _q_init = ao_defer_v()
      client._send = _send_ready

      if false !== err ::
        // call client.on_reconnect in next promise microtask
        _async_evt('on_reconnect')

    async send_connect(... args) ::
      if ! _send_mqtt_pkt ::
        _send_mqtt_pkt = await _q_init[0]

      // await connack response
      let res = await _send_mqtt_pkt(...args)

      // resolve _q_ready[0] with _send_mqtt_pkt closure
      _q_ready[1](client._send = _send_mqtt_pkt)
      _q_ready = ao_defer_v()

      return res

    is_set: @=> !! _send_mqtt_pkt
    set([mqtt_decode, mqtt_encode], send_u8_pkt) ::
      if _send_mqtt_pkt ::
        throw new Error('Already connected')

      let mqtt_ctx = {mqtt: client}
      let on_mqtt_chunk = u8_buf =>
        on_mqtt(mqtt_decode(u8_buf), mqtt_ctx)

      _send_mqtt_pkt = async (type, pkt, key) => ::
        let res = undefined !== key
          ? pkt_future(key) : true

        await send_u8_pkt @
          mqtt_encode(type, pkt)

        return res

      _q_init[1](_send_mqtt_pkt) // resolve _q_init with _send_mqtt_pkt closure

      // call client.on_live in next promise microtask
      _async_evt('on_live')
      return on_mqtt_chunk


  async function _async_evt(evt, err_arg) ::
    let fn_evt = client[evt]
    if fn_evt ::
      try :: // microtask break
        await fn_evt.call(client, client, await err_arg)
      catch err ::
        client.on_error @ err, evt
    else if err_arg ::
      return client.on_error @ await err_arg, evt



function _ping_interval(send_ping) ::
  let tid
  return @\ td ::
    tid = clearInterval(tid)
    if td ::
      tid = setInterval(send_ping, 1000 * td)
      tid.unref?.()

