// Use [regexparam][] for url-like topic parsing
//  [regexparam]: https://github.com/lukeed/regexparam

import {parse as _rxp_parse} from 'regexparam'

function _ignore(pkt, params, ctx) :: ctx.done = true

export function _mqtt_topic_router() ::
  let pri_lsts = [[],[]], rm = Symbol()
  let find = topic => _mqtt_routes_iter(pri_lsts, topic)

  return @{} find,

    add(topic_route, ...args) ::
      let fn = args.pop()
      let priority = args.pop()

      if 'function' !== typeof fn ::
        if false === fn ::
          fn = _ignore
        else throw new TypeError()

      let rte = _rxp_parse @
        topic_route.replace(/[+#]$/, '*')

      rte.key = topic_route
      rte.tgt = fn
      pri_lsts[priority ? 0 : 1].push(rte)
      return this

    remove(topic_route, priority) ::
      let lst = pri_lsts[priority ? 0 : 1]
      return _mqtt_route_remove([lst], topic_route)

    clear(priority) ::
      pri_lsts[priority ? 0 : 1] = []
      if null == priority ::
        pri_lsts[1] = []

    async invoke(pkt, ctx) ::
      ctx.idx = 0
      ctx.rm = rm

      for let [fn, params] of find(pkt.topic) ::
        let res = await fn(pkt, params, ctx)

        if rm === res ::
          _mqtt_route_remove(pri_lsts, fn)

        if ctx.done ::
          break
        else ctx.idx++

      let {pkt_id, qos} = pkt
      if 1 === qos ::
        await ctx.mqtt._send('puback', {pkt_id})


export function * _mqtt_routes_iter(all_route_lists, topic) ::
  for let route_list of all_route_lists ::
    for let route of route_list ::
      let res = _mqtt_route_match_one(topic, route)
      if undefined !== res ::
        yield res


export function _mqtt_route_match_one(topic, {keys, pattern, tgt}) ::
  let match = '/' !== topic[0]
    ? pattern.exec('/'+topic)
    : pattern.exec(topic)

  if null === match ::
    return

  if false === keys ::
    let {groups} = match
    if ! groups ::
      return [tgt]

    let params = {}
    for let k in groups ::
      params[k] = groups[k]

    return [tgt, params]

  if 0 === keys.length ::
    return [tgt]

  let params = {}
  for let i=0; i<keys.length; i++ ::
    params[ keys[i] ] = match[1+i]
  return [tgt, params]


export function _mqtt_route_remove(all_route_lists, query) ::
  let match = route => route===query || route.tgt===query || route.key===query
  for let lst of all_route_lists ::
    let i = lst.findIndex(match)
    if 0 <= i :: return !! lst.splice(i,1)
  return false

