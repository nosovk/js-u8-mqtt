import {_mqtt_conn} from './_conn.jsy'
import {_mqtt_topic_router} from './_router.jsy'
import {_mqtt_dispatch} from './_dispatch.jsy'

export class MQTTBaseClient ::
  constructor(opt={}) ::
    this._conn_ = _mqtt_conn @ this,
      this._init_dispatch(opt, this)

  // Handshaking Packets

  async connect(pkt={}) ::
    let {client_id: cid} = pkt
    if ! cid ::
      pkt.client_id = cid = this.init_client_id(['u8-mqtt--', ''])
    else if Array.isArray(cid) ::
      pkt.client_id = cid = this.init_client_id(cid)
    else :: this.client_id = cid

    if null == pkt.keep_alive ::
      pkt.keep_alive = 60

    let res = await this._conn_
      .send_connect('connect', pkt, 'connack')

    // TODO: merge with server's keep_alive frequency
    this._conn_.ping(pkt.keep_alive)
    return res

  async disconnect(pkt={}) ::
    let res = await this._send('disconnect', pkt)
    this._conn_.reset()
    return res

  auth(pkt={}) ::
    return this._send('auth', pkt, 'auth')

  ping() :: return this._send('pingreq', null, 'pingresp')


  // alias: sub
  subscribe(pkt, ex) ::
    pkt = _as_topics(pkt, ex)
    return this._send('subscribe', pkt, pkt)

  // alias: unsub
  unsubscribe(pkt, ex) ::
    pkt = _as_topics(pkt, ex)
    return this._send('unsubscribe', pkt, pkt)

  get on_topic() :: return this.router.add

  // alias: sub_topic
  subscribe_topic(topic_route, ...args) ::
    let topic = this.topic_for(topic_route)
    this.router.add @ topic_route, true, args.pop() // handler
    this.subscribe @ [[ topic ]], args.pop() // ex
    return this

  // alias: unsub_topic
  unsubscribe_topic(topic_route) ::
    let topic = this.topic_for(topic_route)
    this.router.remove @ topic_route, true
    return this.unsubscribe @ [[ topic ]]

  topic_for(topic_route) ::
    return topic_route.replace(/[:*].*$/, '#')


  // alias: pub
  publish(pkt, fn_encode) :: return _pub(this, pkt, fn_encode)
  post(topic, payload) :: return _pub.m(this, topic, payload)
  send(topic, payload) :: return _pub.mq(this, topic, payload)
  store(topic, payload) :: return _pub.mqr(this, topic, payload)

  json_post(topic, msg) :: return _pub.o(this, topic, msg)
  json_send(topic, msg) :: return _pub.oq(this, topic, msg)
  json_store(topic, msg) :: return _pub.oqr(this, topic, msg)

  obj_post(topic, msg, fn_encode) :: return _pub.o(this, topic, msg, fn_encode)
  obj_send(topic, msg, fn_encode) :: return _pub.oq(this, topic, msg, fn_encode)
  obj_store(topic, msg, fn_encode) :: return _pub.oqr(this, topic, msg, fn_encode)



  // Utility Methods

  init_client_id(parts) ::
    let cid = this.client_id

    if undefined === cid ::
      this.client_id = cid = (
        #IF PLAT_WEB
          this.sess_client_id(parts)
        #ELSE
          this.new_client_id(parts)
        )

    return cid

  new_client_id(parts) ::
    return [parts[0], Math.random().toString(36).slice(2), parts[1]].join('')

  #IF PLAT_WEB
    sess_client_id(parts) ::
      let key = `client_id ${parts.join('')}`
      let cid = sessionStorage.getItem(key)
      if null == cid ::
        cid = this.new_client_id(parts)
        sessionStorage.setItem(key, cid)
      return cid


  // Internal API

  /* async _send(type, pkt) -- provided by _conn_ and transport */

  _init_router(opt) ::
    return this.router = _mqtt_topic_router(this)

  _init_dispatch(opt) ::
    let router = this._init_router(opt, this)

    let tgt = @{}
      __proto__: opt.on_mqtt_type || {}
      router

    if ! tgt.mqtt_publish ::
      tgt.mqtt_publish = router.invoke

    return _mqtt_dispatch(this, tgt)


::
  let p = MQTTBaseClient.prototype
  Object.assign @ p, @{}
    pub: p.publish
    sub: p.subscribe
    unsub: p.unsubscribe
    sub_topic: p.subscribe_topic
    unsub_topic: p.unsubscribe_topic

  /*
    p.on_mqtt_type = {
      mqtt_auth(pkt, ctx) ::
      mqtt_connect(pkt, ctx) ::
      mqtt_connack(pkt, ctx) ::
      mqtt_disconnect(pkt, ctx) ::

      mqtt_publish(pkt, ctx)
      mqtt_subscribe(pkt, ctx) ::
      mqtt_unsubscribe(pkt, ctx) ::

      mqtt_pingreq(pkt, ctx) ::
      mqtt_pingresp(pkt, ctx) ::
    }
  */


function _as_topics(pkt, ex) ::
  if 'string' === typeof pkt ::
    return {topics:[pkt], ... ex}
  if pkt[Symbol.iterator] ::
    return {topics:[... pkt], ... ex}
  return ex ? {...pkt, ...ex} : pkt


function _pub(self, pkt, fn_encode) ::
  if undefined === pkt.payload ::
    let {msg} = pkt
    switch typeof msg ::
      case 'function':
        fn_encode = msg
        msg = undefined

      case 'undefined':
        let arg = pkt.arg || 'payload'
        return v => _pub(self, {...pkt, [arg]: v}, fn_encode)

      default:
        pkt.payload = fn_encode
          ? fn_encode(msg)
          : JSON.stringify(msg)

  return self._send @ 'publish', pkt,
    pkt.qos ? pkt : void 0 // key

::
  Object.assign @ _pub, @{}
    m: (self, topic, payload) =>
      _pub(self, {topic, payload, qos:0})
    mq: (self, topic, payload) =>
      _pub(self, {topic, payload, qos:1})
    mqr: (self, topic, payload) =>
      _pub(self, {topic, payload, qos:1, retain: 1})

    o: (self, topic, msg, fn_encode) =>
      _pub(self, {topic, msg, arg: 'msg', qos:0}, fn_encode)
    oq: (self, topic, msg, fn_encode) =>
      _pub(self, {topic, msg, arg: 'msg', qos:1}, fn_encode)
    oqr: (self, topic, msg, fn_encode) =>
      _pub(self, {topic, msg, arg: 'msg', qos:1, retain: 1}, fn_encode)

