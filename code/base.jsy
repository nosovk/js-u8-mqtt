import {_mqtt_conn} from './_conn.jsy'
import {_mqtt_dispatch} from './_dispatch.jsy'

export class MQTTError extends Error ::
  constructor(mqtt_pkt, reason=mqtt_pkt.reason) ::
    super(`[0x${reason.toString(16)}] ${reason.reason}`)
    this.mqtt_pkt = mqtt_pkt
    this.reason = reason

export class MQTTBase ::
  constructor(opt={}) ::
    this._conn_ = _mqtt_conn @ this,
      this._init_dispatch(opt, this)

  async conn_emit(evt, arg, err_arg) ::
    this.log_conn?.(evt, arg, err_arg)
    try ::
      let fn_evt = this[await evt] // microtask break
      if fn_evt ::
        await fn_evt.call(this, this, arg, err_arg)
      else if err_arg ::
        await this.on_error(err_arg, evt)
    catch err ::
      this.on_error(err, evt)

  on_error(err, err_path) ::
    console.warn @ '[[u8-mqtt error: %s]]', err_path, err

  // Handshaking Packets

  async connect(pkt={}) ::
    let cid = pkt.client_id || ['u8-mqtt--', '']
    if Array.isArray(cid) ::
      pkt.client_id = cid = this.init_client_id(cid)
    this.client_id = cid

    if null == pkt.keep_alive ::
      pkt.keep_alive = 60

    let res = await this._conn_
      .send_connect('connect', pkt, 'connack')

    if 0 != res[0].reason ::
      throw new this.MQTTError(res[0])

    // TODO: merge with server's keep_alive frequency
    this._conn_.ping(pkt.keep_alive)
    return res

  async disconnect(pkt={}) ::
    let res = await this._send('disconnect', pkt)
    this._conn_.reset(false)
    return res

  auth(pkt={}) ::
    return this._send('auth', pkt, 'auth')

  ping() :: return this._send('pingreq', null, 'pingresp')
  puback({pkt_id}) :: return this._send('puback', {pkt_id})

  // alias: sub
  subscribe(pkt, ex, topic_prefix) ::
    pkt = _as_topics(pkt, ex, topic_prefix)
    return this._send('subscribe', pkt, pkt)

  // alias: unsub
  unsubscribe(pkt, ex, topic_prefix) ::
    pkt = _as_topics(pkt, ex, topic_prefix)
    return this._send('unsubscribe', pkt, pkt)


  // alias: pub
  publish(pkt, pub_opt) :: return _pub(this, pkt, pub_opt)
  post(topic, payload, pub_opt) :: return _pub.m(this, topic, payload, pub_opt)
  send(topic, payload, pub_opt) :: return _pub.mq(this, topic, payload, pub_opt)
  store(topic, payload, pub_opt) :: return _pub.mqr(this, topic, payload, pub_opt)

  json_post(topic, msg, pub_opt) :: return _pub.o(this, topic, msg, pub_opt)
  json_send(topic, msg, pub_opt) :: return _pub.oq(this, topic, msg, pub_opt)
  json_store(topic, msg, pub_opt) :: return _pub.oqr(this, topic, msg, pub_opt)

  obj_post(topic, msg, pub_opt) :: return _pub.o(this, topic, msg, pub_opt)
  obj_send(topic, msg, pub_opt) :: return _pub.oq(this, topic, msg, pub_opt)
  obj_store(topic, msg, pub_opt) :: return _pub.oqr(this, topic, msg, pub_opt)



  // Utility Methods

  init_client_id(parts) ::
    let cid = this.client_id

    if undefined === cid ::
      this.client_id = cid = (
        #IF PLAT_WEB
          this.sess_client_id(parts)
        #ELSE
          this.new_client_id(parts)
        )

    return cid

  new_client_id(parts) ::
    return [parts[0], Math.random().toString(36).slice(2), parts[1]].join('')

  #IF PLAT_WEB
    sess_client_id(parts) ::
      let key = parts.join('\x20')
      let cid = sessionStorage.getItem(key)
      if null == cid ::
        cid = this.new_client_id(parts)
        sessionStorage.setItem(key, cid)
      return cid


  // Internal API

  /* async _send(type, pkt) -- provided by _conn_ and transport */

  _init_dispatch(opt) ::
    this.constructor?._once_()
    let target = @{} __proto__: opt.on_mqtt_type
    target.mqtt_publish ||=
      this._init_router?.(opt, this, target)
    return _mqtt_dispatch(this, target)

  static _aliases() ::
    return ' pub:publish sub:subscribe unsub:unsubscribe '

  static _once_(self=this) ::
    self._once_ = _=>0
    self.MQTTError = MQTTError
    let p = self.prototype
    for let alias of self._aliases().split(/\s+/) ::
      alias = alias.split(':')
      let fn = alias[1] && p[alias[1]]
      if fn :: p[alias[0]] = fn


/*
on_mqtt_type = {
  mqtt_auth(pkt, ctx) ::
  mqtt_connect(pkt, ctx) ::
  mqtt_connack(pkt, ctx) ::
  mqtt_disconnect(pkt, ctx) ::

  mqtt_publish(pkt, ctx)
  mqtt_subscribe(pkt, ctx) ::
  mqtt_unsubscribe(pkt, ctx) ::

  mqtt_pingreq(pkt, ctx) ::
  mqtt_pingresp(pkt, ctx) ::
}
*/


const _prefix_topics = (topic_prefix, iterable) =>
  Array.from @ iterable, value => @
    value.trim // string
      ? _prefix_topics(topic_prefix, value)
      : topic_prefix + value

function _as_topics(pkt, ex, topic_prefix) ::
  if ex?.trim :: // string
    topic_prefix = ex
    ex = null

  pkt = @
    pkt.trim // string
      ? {topics:[pkt], ... ex}
    : pkt[Symbol.iterator]
      ? {topics:[... pkt], ... ex}
    : ex ? {...pkt, ...ex}
    : pkt

  if topic_prefix ::
    // particularly useful with shared queues, e.g.
    //   topic_prefix = '$share/some-queue-name/'
    pkt.topics = _prefix_topics(topic_prefix, pkt.topics)
  return pkt


async function _pub(self, pkt, pub_opt) ::
  if undefined === pkt.payload ::
    if 'function' === typeof pub_opt ::
      pub_opt = {fn_encode: pub_opt}

    let {msg} = pkt
    switch typeof msg ::
      case 'function':
        pub_opt = {...pub_opt, fn_encode: msg}
        // flow into 'undefined' case
      case 'undefined':
        // return a single-value closure to publish packets
        return v => _pub(self, {...pkt, [pkt.arg || 'payload']: v}, pub_opt)

      default:
        // Encode payload from msg; fn_encode allows alternative to JSON.stringify
        let {fn_encode} = pub_opt || {}
        pkt.payload = fn_encode
          ? await fn_encode(msg)
          : JSON.stringify(msg)

  if pub_opt ::
    if pub_opt.props ::
      pkt.props = pub_opt.props
    if pub_opt.xform ::
      pkt = pub_opt.xform(pkt) || pkt

  return self._send @ 'publish', pkt,
    pkt.qos ? pkt : void 0 // key

::
  Object.assign @ _pub, @{}
    m: (self, topic, payload, pub_opt) =>
      _pub(self, {topic, payload, qos:0}, pub_opt)
    mq: (self, topic, payload, pub_opt) =>
      _pub(self, {topic, payload, qos:1}, pub_opt)
    mqr: (self, topic, payload, pub_opt) =>
      _pub(self, {topic, payload, qos:1, retain: 1}, pub_opt)

    o: (self, topic, msg, pub_opt) =>
      _pub(self, {topic, msg, arg: 'msg', qos:0}, pub_opt)
    oq: (self, topic, msg, pub_opt) =>
      _pub(self, {topic, msg, arg: 'msg', qos:1}, pub_opt)
    oqr: (self, topic, msg, pub_opt) =>
      _pub(self, {topic, msg, arg: 'msg', qos:1, retain: 1}, pub_opt)

