import {_mqtt_conn} from './_conn.jsy'
import {_mqtt_topic_router} from './_router.jsy'
import {_mqtt_dispatch} from './_dispatch.jsy'

export default class MQTTBaseClient ::
  constructor(opt={}) ::
    const {on_mqtt_type} = opt
    if on_mqtt_type ::
      this.on_mqtt_type = on_mqtt_type

    this._conn_ = _mqtt_conn @ this,
      this._init_dispatch(opt, this)

  static create(opt) :: return new this(opt)

  // Core API:

  new_client_id(pre=[]) ::
    return `${pre[0]||'u8-mqtt--'}${Math.random().toString(36).slice(2)}${pre[1]||''}`

  client_id(pre) ::
    let cid = this._client_id
    if undefined === cid ::
      this._client_id = cid =
        this.new_client_id(pre)
    return cid

  auth(pkt={}) ::
    return this._send('auth', pkt, 'auth')

  async connect(pkt={}) ::
    const {client_id: cid} = pkt
    if ! cid ::
      pkt.client_id = this.client_id()
    else if Array.isArray(cid) ::
      pkt.client_id = this.client_id(cid)

    if null == pkt.keep_alive ::
      pkt.keep_alive = 60

    const res = await this._conn_
      .send_connect @ 'connect', pkt, 'connack'

    // TODO: merge with server's keep_alive frequency
    this._conn_.ping(pkt.keep_alive)
    return res

  async disconnect(pkt={}) ::
    const res = await this._send('disconnect', pkt)
    this._conn_.reset()
    return res

  ping() :: return this._send('pingreq', null, 'pingresp')

  // alias: sub
  subscribe(pkt, ex) ::
    pkt = _as_topics(pkt, ex)
    return this._send('subscribe', pkt, pkt)

  // alias: unsub
  unsubscribe(pkt, ex) ::
    pkt = _as_topics(pkt, ex)
    return this._send('unsubscribe', pkt, pkt)

  // alias: pub
  publish(pkt) :: return _pub @ this, pkt.qos, pkt
  post(topic, payload) :: return _pub @ this, 0, {topic, payload}
  send(topic, payload) :: return _pub @ this, 1, {topic, payload}
  json_post(topic, msg) :: return _pub @ this, 0, {topic, msg, arg:'msg'}
  json_send(topic, msg) :: return _pub @ this, 1, {topic, msg, arg:'msg'}

  // alias: sub_route
  subscribe_route(topic, ...args) ::
    this.add_route @ true, topic, args.pop()
    this.subscribe @#
      @[] topic, args.shift()|0 // qos
    return this


  /* async _send(type, pkt) -- provided by _conn_ and transport */

  on_live(client) ::

  _init_router(opt) ::
    const router = _mqtt_topic_router(this)
    this.add_route = router.add
    return this.router = router

  _init_dispatch(opt) ::
    const router = this._init_router(opt, this)

    const tgt = @{}
      __proto__: this.on_mqtt_type || {}
      mqtt_publish: router.invoke

    return _mqtt_dispatch @ this, tgt


::
  const p = MQTTBaseClient.prototype
  Object.assign @ p, @{}
    pub: p.publish
    sub_route: p.subscribe_route
    sub: p.subscribe
    unsub: p.unsubscribe

  /*
    p.on_mqtt_type = {
      mqtt_auth(pkt, ctx) ::
      mqtt_connect(pkt, ctx) ::
      mqtt_connack(pkt, ctx) ::
      mqtt_disconnect(pkt, ctx) ::

      mqtt_subscribe(pkt, ctx) ::
      mqtt_unsubscribe(pkt, ctx) ::

      mqtt_pingreq(pkt, ctx) ::
      mqtt_pingresp(pkt, ctx) ::
    }
  */


function _pub(self, qos, pkt) ::
  let key, {msg, payload} = pkt
  if undefined === payload ::
    if undefined === msg ::
      const arg = pkt.arg || 'payload'
      return v => _pub @ self, qos, {...pkt, [arg]: v}

    pkt.payload = JSON.stringify(msg)

  if qos > 0 :: key = pkt
  return self._send @ 'publish', pkt, key

function _as_topics(pkt, ex) ::
  if 'string' === typeof pkt ::
    return {topics:[pkt], ... ex}
  if pkt[Symbol.iterator] ::
    return {topics:[... pkt], ... ex}
  return ex ? {...pkt, ...ex} : pkt

